<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>STDCL Reference Manual</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/" />
  <style type="text/css" title="Amaya theme">
/* Modern style for Amaya Editor Lite */

/* default rules for the whole document */
body {
    font-size: 12pt;
    font-family: Times New Roman,Times,serif; /* Helvetica, Arial, sans-serif; */
    font-weight: normal;
    font-style: normal;
    color: black;
    background-color: white;
    line-height: 1.2em;
    margin-left: 4em;
    margin-right: 2em;
   }

/* paragraphs */
p  {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }

/* headings */
h1 {
    font-size: 180%;
    font-weight: bold;
    font-style: normal;
    font-variant: small-caps;
    text-align: left;
    padding: 0;
    margin-top: 1.7em;
    margin-bottom: 1.7em;
   }
h2 {
    font-size: 150%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.5em;
    margin-bottom: 1.1em;
   }
h3 {
    font-size: 130%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.3em;
    margin-bottom: 1.1em;
   }
h4 {
    font-size: 110%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.1em;
    margin-bottom: 1.1em;
   }
h5 {
    font-size: 100%;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }
h6 {
    font-size: 100%;
    font-weight: normal;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }

/* divisions */
div {
    padding: 0;
    margin-top: 0em;
    margin-bottom: 0em;
   }

/* lists */
ul, ol {
    padding: 0 0 0 3em;
    margin-top: 1em;
    margin-bottom: 1em;
   }
ul ul, ol ol, ul ol, ol ul {
    margin-top: 1em;
    margin-bottom: 1em;
   }
li {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }
li p {
    margin-top: 1em;
    margin-bottom: 1em;
   }
dl {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    margin-left: 1em;
   }
dl dl {
    margin-top: 0em;
    margin-bottom: 0em;
   }
dt {
    padding: 0;
    font-weight: bold;
    margin-top: .3em;
    margin-bottom: .3em;
   }
dd {
    padding: 0;
    margin-top: .3em;
    margin-left: 3em;
    margin-bottom: .3em;
   }
dl p {
    margin-top: .3em;
    margin-bottom: .3em;
   }

/* inline */
strong {
    font-weight: bold;
   }
em {
    font-style: italic;
   }
code {
    font-family: Courier New, Courier, monospace;
   }
ins {
    background-color: yellow;
    text-decoration: underline;
   }
del {
    text-decoration: line-through;
   }

/* anchors */
a[href] {
    color: blue;
    text-decoration: underline;
   }

/* end */
  </style>
</head>

<body>
<p><img alt="" src="img/bdt.jpg" width="201" height="70" /></p>

<h1 style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">STDCL</span></span> </h1>

<h2 style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">A Simplified C Interface for
OpenCL</span></span></h2>

<p style="text-align:center;margin-left:auto;margin-right:auto;">revision
1.2</p>

<p style="text-align:center;margin-left:auto;margin-right:auto;">Copyright ©
2009-2011 Brown Deer Technology, LLC</p>

<p style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-size: 10pt"><span
style="font-family: Times New Roman,Times,serif"><em>Verbatim copying and
distribution of this entire document is </em></span></span><span
style="font-family: Times New Roman,Times,serif"><span
style="font-size: 10pt"><em>permitted </em></span></span><span
style="font-size: 10pt"><span
style="font-family: Times New Roman,Times,serif"><em>in any medium, provided
this notice is preserved.</em></span></span></p>
<hr />

<h2>Contents</h2>
<ul>
  <li><a href="#Name">Name</a></li>
  <li><a href="#Version">Version</a></li>
  <li><a href="#Synopsis">Synopsis</a></li>
  <li><a href="#Descriptio">Description</a></li>
  <li><a name="Applicatio1" id="Applicatio1" href="#Applicatio">Application
    Programming Interface (API)</a></li>
  <li style="margin-left:2em;"><a href="#Default">Default Contexts</a></li>
  <li style="margin-left:2em;"><a href="#Dynamic">Dynamic CL Program
  Loader</a></li>
  <li style="margin-left:2em;"><a href="#Memory">Memory Management</a></li>
  <li style="margin-left:2em;"><a href="#Kernel">Kernel Management</a></li>
  <li style="margin-left:2em;"><a href="#Synchroniz">Synchronization</a></li>
  <li style="margin-left:2em;"><a href="#Environmen">Environment
  Variables</a></li>
  <li><a href="#Examples">Examples</a></li>
  <li><a href="#Manual">Manual Pages</a></li>
</ul>
<hr />

<h2><a name="Name" id="Name">Name</a></h2>

<p><span style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">STDCL - Standard Compute Layer
Interface</span></span></p>

<p></p>
<hr />

<h2><a name="Version" id="Version">Version</a></h2>

<p><span
style="font-family: Courier New,Courier,monospace">STDCL_VERSION_STR</span></p>

<p><span
style="font-family: Courier New,Courier,monospace">STDCL_VERSION_HEX</span></p>

<p></p>
<hr />

<h2><a name="Synopsis" id="Synopsis">Synopsis</a></h2>
<pre><span style="font-family: Courier New,Courier,monospace"><span style="font-family: Times New Roman,Times,serif">#include &lt;stdcl.h&gt;</span></span>

<span style="font-family: Times New Roman,Times,serif"><span style="font-family: Courier New,Courier,monospace">Link with -lstdcl.</span> </span></pre>
<dl>
  <dt>Default Contexts</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">stddev, stdcpu,
      stdgpu, stdrpu,</span></span></span></dd>
    <dd><code>clgetndev()</code></dd>
  <dt>Dynamic CL Program loader</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clopen(), clsym(),
      clclose(), clbuild()</span></span></span></dd>
  <dt>Memory Management</dt>
    <dd><span style="font-family: Courier New,Courier,monospace">clmalloc(),
      clmrealloc(), clfree(), clglmalloc(), </span></dd>
    <dd><span style="font-family: Courier New,Courier,monospace">clmctl(),
      clmctl_va(),</span></dd>
    <dd><span style="font-family: Courier New,Courier,monospace">clmattach(),
      clmdetach(), clsizeofmem(), clmsync(), clglmsync()</span></dd>
  <dt>Kernel Management</dt>
    <dd><span style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clndrange_init1d(),
      clndrange_init2d(), clndrange_init3d(),</span></span></span></span></dd>
    <dd style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clarg_set(),
      clarg_set_local(), clarg_set_global(), </span></dd>
    <dd><span style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clfork()</span></span></span></span></dd>
  <dt>Synchronization</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><code>clflush(),
      clwait()</code></span></span></dd>
  <dt>Environment Variables</dt>
    <dd>STDDEV, STDCPU, STDGPU, STDRPU,</dd>
    <dd>STD[DEV|CPU|GPU|RPU]_PLATFORM_NAME,</dd>
    <dd>STD[DEV|CPU|GPU|RPU]_MAX_NDEV,</dd>
    <dd>STD[DEV|CPU|GPU|RPU]_LOCK</dd>
  <dt></dt>
</dl>
<hr />

<h2><a name="Descriptio" id="Descriptio">Description</a></h2>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">OpenCL provides a host-side
API that allows the careful management of memory and processes on heterogeneous
computing platforms. The level of control is more typically reserved for
conventional operating systems (memory management, process management,
synchronization, etc.). Although this granularity of control is necessary to
support the expansive industry objectives for which OpenCL was designed, the
granularity of control and verbose nature of the API proves to be tedious
within the context of typical software application development. The steps
required for a simple Hello World OpenCL program are tedious and repetitive
from a programmer's perspective. Moreover, some semantics introduced by OpenCL
have more natural and familiar constructs within traditional UNIX programming
that can greatly simplify the use of the API and prove more efficient. As an
example, opaque memory buffers are more naturally managed as memory
allocations; modern UNIX-like operating systems are more than capable of
employing memory virtualization sufficient to allow control over memory
consistency. </span></p>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides a simplified C
interface to OpenCL designed in a style familiar to traditional UNIX/C
programmers. The design and implementation of STDCL is inspired by familiar
APIs designed for different purposes, e.g., stdio.h (for default contexts),
dlopen (for managing OpenCL kernels), malloc (as a replacement for creating
opaque memory buffers), and fork (as a replacement to "enqueueing commands on
the command queue"). In every detail, the approach is to avoid introducing new
inventive syntax and semantics in favor of exploiting permutations of more
familiar syntax and semantics from traditional UNIX. Whether the effort
succeeds is for the programmer to decide.</span></p>

<p></p>
<hr />

<h2><a name="Applicatio" id="Applicatio">Application Programming Interface
(API)</a></h2>

<p>The STDCL interface provides support for <a href="#Default"><em>default
contexts</em></a>, <a href="#Dynamic"><em>dynamic CL program loader</em></a>,
<a href="#Memory"><em>memory management</em></a>, <a href="#Kernel"><em>kernel
execution</em></a>, and <em><a href="#Asynchrono">asynchronous
operations</a></em>. In addition, <a href="#Environmen">environment
variables</a> provide run-time control over certain aspects of the interface.
The STDCL interface is discussed in detail below. </p>

<p></p>

<h3><a name="Default" id="Default">Default Contexts</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides several default
contexts similar to the default I/O streams provided by stdio. These default
contexts are defined to include the most typical use-cases. Each default
context is of type </span><span
style="font-family: Courier New,Courier,monospace">CLCONTEXT,<span
style="font-family: Times New Roman,Times,serif"></span></span> <span
style="font-family: Times New Roman,Times,serif">which is defined as a superset
of the OpenCL type </span><span
style="font-family: Courier New,Courier,monospace">cl_context<span
style="font-family: Times New Roman,Times,serif"></span></span>. <span
style="font-family: Times New Roman,Times,serif">The following default contexts
are provided:</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>CLCONTEXT*
stddev;</strong></span> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All devices for a given
platform supported by the OpenCL API.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">CLCONTEXT*
stdcpu;</span></strong> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All multi-core CPU processors
for a given platform supported by the OpenCL API.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">CLCONTEXT*
stdgpu;</span></strong> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All many-core GPU processors
for a given platform supported by the OpenCL API.</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>CLCONTEXT*
stdrpu;</strong></span> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All reconfigurable processors
for a given platform supported by the OpenCL API.</span></p>

<p><strong><code>cl_uint clgetndev( CLCONTEXT* cp );</code></strong></p>

<p style="margin-left:2em;">This call returns the number of devices in the CL
context cp.</p>

<p></p>

<h3><a name="Dynamic" id="Dynamic">Dynamic CL Program Loader</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides a convenient
interface for dynamically loading CL programs and accessing OpenCL kernels. The
functions <span
style="font-family: Courier New,Courier,monospace">clopen()</span>, <span
style="font-family: Courier New,Courier,monospace">clsym()</span> and <span
style="font-family: Courier New,Courier,monospace">clclose()</span> are
designed to mirror the semantics of the more familiar functions <span
style="font-family: Courier New,Courier,monospace">dlopen()</span>, <span
style="font-family: Courier New,Courier,monospace">dlsym()</span> and <span
style="font-family: Courier New,Courier,monospace">dlclose()</span> used to
access the Linux dynamic loader. The following functions are provided for
dynamically loading CL programs and accessing OpenCL kernels:</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void*
clopen( CLCONTEXT* cp, const char* filename, int flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call opens a file
containing the source or binary program defining one or more OpenCL kernels and
performs the steps necessary to create and build the OpenCL program object. A
handle is returned that can be used in subsequent calls to access the actual
kernels in the program. The handle is valid within the</span> <span
style="font-family: Courier New,Courier,monospace">CLCONTEXT</span> <span
style="font-family: Times New Roman,Times,serif">specified by </span><span
style="font-family: Courier New,Courier,monospace"><strong>cp<span
style="font-family: Times New Roman,Times,serif"></span></strong></span>. </p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">If </span><span
style="font-family: Courier New,Courier,monospace"><strong>filename</strong></span>
<span style="font-family: Times New Roman,Times,serif">is a </span><span
style="font-family: Courier New,Courier,monospace"><span
style="font-family: Times New Roman,Times,serif">NULL</span><span
style="font-family: Times New Roman,Times,serif"></span></span> pointer <span
style="font-family: Times New Roman,Times,serif">then a handle to the OpenCL
program(s) embedded in the host program executable is returned. (See the tool
</span><span style="font-family: Courier New,Courier,monospace">clld<span
style="font-family: Times New Roman,Times,serif"></span></span> <span
style="font-family: Times New Roman,Times,serif">for a description of how to
embed OpenCL source and binary programs into a host program
executable.)</span></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">The </span><strong><span
style="font-family: Courier New,Courier,monospace">flags<span
style="font-family: Times New Roman,Times,serif"></span></span></strong><span
style="font-family: Times New Roman,Times,serif">argument allows control over
the behavior of the function. The flag <span
style="font-family: Courier New,Courier,monospace">CLLD_NOW</span> instructs
the call to perform all of the steps involved with creating and building the
program; the flag <span
style="font-family: Courier New,Courier,monospace">CLLD_LAZY</span> instructs
the call to defer these steps until the handle is first used. The call accepts
a flag set to <span style="font-family: Courier New,Courier,monospace">0</span>
in which case the default behavior <span
style="font-family: Courier New,Courier,monospace">(CLLD_NOW)</span> is used.
</span></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">If the <strong>flags</strong>
argument <code>CLLD_NOBUILD</code> is used the compilation and build process is
deferred, and a subsequent call to <code>clbuild()</code> must be used for the
returned handle to reflect a valid (compiled and built) program. This flag is
useful when the user needs to pass in compiler options, which can be done with
the <code>clbuild()</code> call.</span></p>

<p style="margin-left:2em;">By default the following compiler options will
always be passed to the low-level OpenCL calls:</p>

<p style="margin-left:4em"><code>-D __STDCL__</code></p>

<p style="margin-left:4em"><code>-D __CPU__</code> | <code>__GPU__</code></p>

<p style="margin-left:4em"><code>-D __AMD__ | __NVIDIA__ |
__coprthr__</code></p>

<p style="margin-left:4em"><code>-I $(CWD)</code></p>

<p><strong><code>void* clsopen( CLCONTEXT* cp, const char* srcstr, int flags
);</code></strong></p>

<p style="margin-left:2em;">This call behaves exactly like
<code>clopen()</code> with the exception that instead of providing the name of
a file containing the OpenCL kernel source, the kernel code may be provided
directly as a string. This call can be useful within schemes where custom
kernel source is generated at run-time.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">cl_kernel
clsym( CLCONTEXT* cp, void* handle, const char* symbol, int
flags);</span></strong></p>

<p
style="margin-left:2em;text-align:justify;font-family: Times New Roman,Times,serif">This
call takes a <strong><span
style="font-family: Courier New,Courier,monospace">handle</span></strong>
returned from a call to <span
style="font-family: Courier New,Courier,monospace">clopen()</span> and returns
the OpenCL kernel specified by <strong><span
style="font-family: Courier New,Courier,monospace">symbol</span></strong>. The
OpenCL kernel is created within the <span
style="font-family: Courier New,Courier,monospace">CLCONTEXT</span> specified
by <strong>cp</strong>. </p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">The argument <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> allows
control over the behavior of the function. The flag <span
style="font-family: Courier New,Courier,monospace">CLLD_NOW</span> instructs
the call to perform all of the steps involved with creating the kernel; the
flag <span style="font-family: Courier New,Courier,monospace">CLLD_LAZY</span>
instructs the call to defer these steps until the kernel is first used. The
call accepts a flag set to <span
style="font-family: Courier New,Courier,monospace">0</span> in which case the
default behavior <span
style="font-family: Courier New,Courier,monospace">(CLLD_NOW)</span> is
used.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">int
clclose( CLCONTEXT* cp, void* handle);</span></strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call decrements the
reference count on the associated handle. If the reference count drops to zero
then the associated OpenCL program source or binary is unloaded and the
associated file is closed. Under normal usage this call is used to safely
release the OpenCL programs created by a call to <span
style="font-family: Courier New,Courier,monospace">clopen()</span>.</span></p>

<p><strong><code>void* clbuild( CLCONTEXT* cp, void* handle, char* options, int
flags );</code></strong></p>

<p style="margin-left:2em;">This call is used following a call to
<code>clopen()</code> or <code>clsopen()</code> with the
<code>CLLD_NOBUILD</code> flag. Calling <code>clbuild()</code> will complete
the porocess of compilinng and building the kernel program. This call accepts
user-specified compiler options. The handle passed in must be a valid handle
created by a call to <code>clopen()</code> or <code>clsopen()</code> with the
<code>CLLD_NOBUILD</code> flag. <code></code>Calling <code>clbuild()</code>
will complete the porocess of compilinng and building the kernel program. This
call accepts user-specified compiler options. The handle passed in must be a
valid handle created by a call to <code>clopen()</code> or
<code>clsopen()</code> with the <code>CLLD_NOBUILD</code> flag. In addition to
the user defined compiler options, the standard compiler options described for
<code>clopen()</code> are also passed to low-level OpenCL calls.</p>

<p></p>

<h3><a name="Memory" id="Memory">Memory Management</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides functions for
allocating and managing memory that may be shared between the host and OpenCL
co-processor devices. Memory may be allocated with clmalloc() and used
transparently as the global memory for kernel execution on a OpenCL device. The
programmer uses a single pointer representing the allocated memory which may be
re-attached to various CL contexts using clmattach() and clmdetach(). Memory
consistency can be maintained using the clmsync() function which synchronizes
memory between the host and OpenCL co-processor devices. </span><span
style="font-family: Times New Roman,Times,serif">The following functions are
provided for OpenCL memory management.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void*
clmalloc( CLCONTEXT* cp, size_t size, int flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call allocates memory
suitable for sharing between OpenCL co-processor devices within a CL context.
The size of the allocation is specified in bytes. The memory is not cleared.
The last argument is used to pass flags to control the behavior of function.
The flag <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DETACHED</span> may
be used to allocate memory that is not attached to a CL context in which case
<strong style="font-family: Courier New,Courier,monospace">cp</strong> must be
0. If <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is 0
the default behavior is to allocate memory attached to a specified CL context.
</span></p>

<p><strong><code>void* clmrealloc( CLCONTEXT* cp, void* ptr, size_t size, int
flag);</code></strong></p>

<p style="margin-left:2em;">This call re-allocates memory suitable for sharing
between OpenCL co-processor devices within a CL context and may be used to
change the size of an existing allocation. The ptr argument must be a valid
memory allocation erturned by either <code>clmalloc()</code>, or a previous
call to <code>clmrealloc()</code>. The size of the allocation is specified in
bytes. The memory is not cleared. The last argument is used to pass flags to
control the behavior of function. The flag <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DETACHED</span> may
be used to allocate memory that is not attached to a CL context in which case
<strong style="font-family: Courier New,Courier,monospace">cp</strong> must be
0. If <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is 0
the default behavior is to allocate memory attached to a specified CL context.
</p>

<p><strong><code>void* clglmalloc( CLCONTEXT* cp, cl_GLuint glbufobj, int
flag);</code></strong></p>

<p style="margin-left:2em;">This call allocates memory suitable for sharing
between OpenCL co-processor devices within a CL context based on an existing
OpenGL memory buffer <strong><code>glbufobj</code></strong>. The size of the
allocation is implied by the OpenGL buffer size. The memory is not cleared. The
last argument is used to pass flags to control the behavior of function. The
flag <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DETACHED</span> may
be used to allocate memory that is not attached to a CL context in which case
<strong style="font-family: Courier New,Courier,monospace">cp</strong> must be
0. If <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is 0
the default behavior is to allocate memory attached to a specified CL context.
</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void
clfree( void* ptr);</span></strong></p>

<p style="text-align:justify;margin-left:2em">This call frees memory allocated
with <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>. The
memory specified by <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> can be
either attached or detached from a CL context. Calling <span
style="font-family: Courier New,Courier,monospace">clfree()</span> with
<strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> equal to
<span style="font-family: Courier New,Courier,monospace">0</span> is considered
an error. </p>

<p><strong><span style="font-family: Courier New,Courier,monospace">size_t
clsizeofmem(void* ptr);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call returns the size in
bytes of the memory allocated with <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>.
</span></p>

<p><strong><code>int clmctl( void* ptr, int op, ... );</code></strong></p>

<p><code><strong>int clmctl_va( void* ptr, int op, va_list
);</strong></code></p>

<p style="margin-left:2em;">These calls provide generalized control over a
device-sharable memory allocation and differ only in the way optional arguments
are passed in. the <strong><code>ptr</code></strong> argument is a pointer to
device-sharable memory returned by any of the calls <code>clmalloc()</code>,
<code>clmrealloc(),</code> or <code>clglmalloc()</code>. The following
operations for the op argument are presently valid:</p>
<dl>
  <dt style="margin-left:2em;">CL_MCTL_SET_IMAGE2D</dt>
    <dd style="margin-left:4em">Mark the allocation to be of OpenCL image2d_t
      type. Optional arguments are: 
      <dl>
        <dt>size_t sz0</dt>
          <dd>Image width</dd>
        <dt>size_t sz1</dt>
          <dd>Image height </dd>
        <dt>size_t sz2</dt>
          <dd>Should be set to 0</dd>
        <dt>cl_image_format* fmt</dt>
          <dd>(Optional) pointer to image format struct, ignored if set to
          NULL</dd>
      </dl>
    </dd>
</dl>

<p><strong><span style="font-family: Courier New,Courier,monospace">cl_event
clmsync( CLCONTEXT* cp, unsigned int devnum, void* ptr, int
flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to
synchronize memory between the host platform and OpenCL co-processor devices.
The memory specified by <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> must
have been allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span> and
associated with a CL context. </span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">The behavior of <span
style="font-family: Courier New,Courier,monospace">clmsync()</span> is
controlled by the <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong>
argument which must be set with either <span
style="font-family: Courier New,Courier,monospace">CL_MEM_HOST</span> or <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DEVICE</span>. These
flags are mutually exclusive and it is an error to set both or none. In
addition the flags <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> and
<span style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span>
control the blocking behavior for the call. For a blocking call the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span>
may be specified to prevent the call from releasing OpenCL events created as a
result of the call.</span><span
style="font-family: Times New Roman,Times,serif">If the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span> is
specified, the programmer is responsible for releasing the returned event with
the OpenCL call <span
style="font-family: Courier New,Courier,monospace">clReleaseEvent()</span>.</span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">The following examples
demonstrate typical uses of <span
style="font-family: Courier New,Courier,monospace">clmsync()</span>:</span></p>

<p style="margin-left:2em;">Non-blocking sync to device memory:</p>

<p style=" margin-bottom: 0em; margin-top: 0em; ;margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_DEVICE|CL_EVENT_NOWAIT);</span></p>

<p style="margin-left:2em;">Non-blocking sync to host memory:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_HOST|CL_EVENT_NOWAIT);</span></p>

<p style="margin-left:2em;">Blocking sync to device memory:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_DEVICE|CL_EVENT_WAIT);</span></p>

<p style="margin-left:2em;">Blocking sync to host with release of event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_HOST|CL_EVENT_WAIT);</span></p>

<p><strong><code>cl_event clglmsync( CLCONTEXT* cp, unsigned int devnum, void*
ptr, int flags);</code></strong></p>

<p style="margin-left:2em;">This call is used to sync memory between
device-sharable memory and OpenGL buffers.</p>

<p style="margin-left:2em;">The flags argument must be set to either
CL_MEM_CLBUF or CL_MEM_GLBUF to define the destination of the sync
operation.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">int
clmattach( CLCONTEXT* cp, void* ptr );</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to attach
memory allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span> to a CL
context. </span><span style="font-family: Times New Roman,Times,serif">In order
to change the attachment of memory from one CL context to another, the memory
must first be unattached using a call to <span
style="font-family: Courier New,Courier,monospace">clmdetach()</span>. It is an
error to call with a <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> to
memory that is already attached to a CL context. </span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>int
clmdetach( void* ptr );</strong></span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to detach
memory from a CL context. The memory must have been allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>.</span></p>

<h3><a name="Kernel" id="Kernel">Kernel Management</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides simplified
interfaces for setting up the index-space and arguments for kernel execution.
Executing a kernel on an OpenCL co-processor device is supported using clfork()
which allows blocking and non-blocking execution behavior. The following
functions are provided for OpenCL kernel management.</span></p>

<p style="line-height:1em;"><strong><span
style="font-family: Courier New,Courier,monospace">clndrange_t
clndrange_init1d( gtoff0,gtsz0,ltsz0); <br />
clndrange_t clndrange_init2d( gtoff0,gtsz0,ltsz0, gtoff1,gtsz1,ltsz1); <br />
clndrange_t clndrange_init3d( gtoff0,gtsz0,ltsz0, gtoff1,gtsz1,ltsz1,
gtoff2,gtsz2,ltsz2);</span></strong></p>

<p style="margin-left:2em;text-align:justify;">The <span
style="font-family: Courier New,Courier,monospace">clndrange_init*()</span>
functions are used to <em>initialize</em> a variable of type <span
style="font-family: Courier New,Courier,monospace">clndrange_t</span> used to
store the OpenCL index-space over which a kernel is to execute. These functions
will be implemented as macros to allow for struct initialization in C. The
arguments <strong><span
style="font-family: Courier New,Courier,monospace">gtoff</span></strong>,
<strong><span
style="font-family: Courier New,Courier,monospace">gtsz</span></strong> and
<strong><span
style="font-family: Courier New,Courier,monospace">ltsz</span></strong>
represent the global offset, global size and local size of the index-space for
a given dimension, respectively. As an example, the following initializes a two
dimensional OpenCL NDRange with no offsets over a global index space of size
512 by 2048 with a local work group size of 4 by 16:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clndrange_t ndr =
clndrange_init2d( 0,512,4 0,2048,16);</span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void clarg_set(
CLCONTEXT* cp, cl_kernel krn, unsigned int argnum, Tn arg );</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments of intrinsic non-pointer type that
are to be passed by value. The size of the argument is inferred from the type
of the argument and may be a vector type, e.g., <span
style="font-family: Courier New,Courier,monospace">cl_float4</span>. </span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void
clarg_set_global( CLCONTEXT* cp, cl_kernel krn, unsigned int argnum, void* ptr
);</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments that are pointers to global memory
as defined in the OpenCL specification. The memory must have been allocated by
<span style="font-family: Courier New,Courier,monospace">clmalloc()</span> in
the appropriate CL context of the kernel. </span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void
clarg_set_local( CLCONTEXT* cp, cl_kernel krn, unsigned int argnum, size_t
sizeb );</strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments that are pointers to local memory as
defined in the OpenCL specification. Local memory of size <strong><span
style="font-family: Courier New,Courier,monospace">sizeb</span></strong> bytes
will be allocated for use by the OpenCL kernel.</span></p>

<p><strong style="font-family: Courier New,Courier,monospace">cl_event clfork(
CLCONTEXT* cp, unsigned int devnum, cl_kernel krn, clndrange* ndr, int flags
);</strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call is used to execute a
kernel on the OpenCL co-processor device specified by <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>. The
arguments for the kernel must be set prior to the call to <span
style="font-family: Courier New,Courier,monospace">clfork()</span> using the
<span style="font-family: Courier New,Courier,monospace">clarg_set*()</span>
functions described above. The kernel is executed over an index-space of
work-items defined by <strong><span
style="font-family: Courier New,Courier,monospace">ndr</span></strong>.</span></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">The behavior of <span
style="font-family: Courier New,Courier,monospace">clfork()</span> may be
controlled using the flags <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> or
<span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span>.
Specifying the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span> will
cause <span style="font-family: Courier New,Courier,monospace">clfork()</span>
to return immediately. Specifying the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> will
cause <span style="font-family: Courier New,Courier,monospace">clfork()</span>
to block until the kernel execution is complete. Including the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span>
will prevent the event associated with the kernel execution to be released for
blocking calls to <span
style="font-family: Courier New,Courier,monospace">clfork()</span>. If the flag
<span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span> is
specified the programmer is responsible for releasing the returned event with
the OpenCL call <span
style="font-family: Courier New,Courier,monospace">clReleaseEvent()</span>.</span></p>

<p style="margin-left:2em;">The following examples demonstrate typical uses of
<span style="font-family: Courier New,Courier,monospace">clfork()</span>:</p>

<p style="margin-left:2em;">Blocking execution of a kernel on device number 0
automatically releasing the associated event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clfork( stdgpu, 0, my_krn,
&amp;ndr, CL_EVENT_WAIT);</span></p>

<p style="margin-left:2em;">Non-blocking execution of a kernel on device number
2 automatically releasing the associated event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clfork( stdgpu, 2, my_krn,
&amp;ndr, CL_EVENT_NOWAIT);</span></p>

<p></p>

<h3><a name="Synchroniz" id="Synchroniz">Synchronization</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides functions for
synchronization to manage the inherently asynchronous operations enabled by
OpenCL per device within each CL context.</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>int
clflush( CLCONTEXT* cp, unsigned int devnum, int flags );</strong></span></p>

<p style="margin-left:2em;text-align:justify;">This call is used to flush all
commands enqueued in the command queue associated with the OpenCL device
specified by the device number <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>
within the specified CL context. For typical OpenCL implementations this is
necessary to force the execution of commands without blocking on the host. A
call to <span
style="font-family: Courier New,Courier,monospace">clflush()</span> is
non-blocking and will return immediately. At present the argument <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> should
be set to <span style="font-family: Courier New,Courier,monospace">0</span>.</p>

<p><strong style="font-family: Courier New,Courier,monospace">cl_event clwait(
CLCONTEXT* cp, unsigned int devnum, int flags );</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to block on
the completion of all commands enqueued in the command queue associated with
the OpenCL device specified by the device number <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>
within the specified CL context. </span></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">The <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong>
argument is used to control the behavior of the call as follows. The flag <span
style="font-family: Courier New,Courier,monospace">CL_KERNEL_EVENT</span> will
cause the call to block on completion of all enqueued kernel events enqueued by
calls to <span
style="font-family: Courier New,Courier,monospace">clfork()</span>. the flag
<span style="font-family: Courier New,Courier,monospace">CL_MEM_EVENT</span>
will cause the call to block on completion of all enqueued memory events
enqueued by call to <span
style="font-family: Courier New,Courier,monospace">clmsync()</span>. The flags
<span style="font-family: Courier New,Courier,monospace">CL_KERNEL_EVENT</span>
and <span
style="font-family: Courier New,Courier,monospace">CL_MEM_EVENT</span> may be
combined in a single call. Including the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span>
will prevent all OpenCL events to be released before <span
style="font-family: Courier New,Courier,monospace">clwait()</span>
returns.</span> If the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span> is
specified the programmer is responsible for releasing all events with the
OpenCL call clReleaseEvent(). </p>

<p style="margin-left:2em;text-align:justify;">The following examples
demonstrate typical uses of <span
style="font-family: Courier New,Courier,monospace">clwait()</span>:</p>

<p style="margin-left:2em;">Block on completion of all kernel execution events
on OpenCL device number 0 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 0,
CL_KERNEL_EVENT );</span></p>

<p style="margin-left:2em;">Block on completion of all memory events on OpenCL
device number 2 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 2,
CL_MEM_EVENT );</span></p>

<p style="margin-left:2em;">Block on completion of all kernel and memory events
on OpenCL device number 2 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 2,
CL_ALL_EVENT );</span></p>

<p></p>

<h3><a name="Environmen" id="Environmen">Environment Variables</a></h3>

<p>The run-time behavior of STDCL can be controlled using environment variables
as follows.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">STDDEV,
</span></strong><span
style="font-family: Courier New,Courier,monospace"><strong>STDCPU,
</strong></span><span
style="font-family: Courier New,Courier,monospace"><strong>STDGPU,
</strong></span><span
style="font-family: Courier New,Courier,monospace"><strong>STDRPU</strong></span></p>

<p style="margin-left:2em;">Each default CL context is can be controlled by the
associated environment variable. A value of 0 or 1 will disable or enable the
context, respectively. The default behavior is to attempt to enable the context
if valid devices are available within the selected platform.</p>

<p
style="margin-left:0em"><strong><code>STD[DEV|CPU|GPU|RPU]_PLATFORM_NAME</code></strong></p>

<p style="margin-left:2em;">Set the platform name for the desired platform to
be used for a given context. If none is provided or the specified platform is
unavailable, a default will be selected.</p>

<p><strong><code>STD[DEV|CPU|GPU|RPU]_MAX_NDEV</code></strong></p>

<p style="margin-left:2em;">Set the maximum number of devices for a given
context regardless of whether more devices exist for the selected platform. If
there is an insufficient number of devices, the maximum available will be
provided.</p>

<p><strong><code>STD[DEV|CPU|GPU|RPU]_LOCK</code></strong></p>

<p style="margin-left:2em;">Set a lock ID for the process to enforce exclusive
access to the provided devices across all processes run with the same lock ID.
This feature is primarily useful to ensure the multiple MPI processes on a
multi-GPU platform are each given exclusive access to a GPU with no requirement
on the application itself.</p>

<p></p>
<hr />

<h2><a name="Examples" id="Examples">Examples</a></h2>

<p><span style="font-family: Times New Roman,Times,serif">The following example
shows the use of STDCL for a simple program that adds two vectors on a GPU or a
CPU:</span></p>

<div style="background-color:#e8e8e8;">
<pre>/* example #1 */

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include &lt;stdcl.h&gt;

#define SIZE 1024

int main()
{
   int i;

   CLCONTEXT* cp = (stdgpu)? stdgpu : stdcpu;

   void* clh = clopen(cp, "add_vec.cl",CLLD_NOW);
   cl_kernel k_addvec = clsym(cp, clh, "addvec_kern", CLLD_NOW);

   float* aa = (float*)clmalloc(cp,SIZE*sizeof(float),0);
   float* bb = (float*)clmalloc(cp,SIZE*sizeof(float),0);
   float* cc = (float*)clmalloc(cp,SIZE*sizeof(float),0);

   for(i=0;i&lt;SIZE;i++) {
      aa[i] = 111.0f * i;
      bb[i] = 222.0f * i;
   }

   bzero(cc,SIZE*sizeof(float));

   clndrange_t ndr = clndrange_init1d(0,SIZE,64);

   clmsync(cp,0,aa,CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,0,bb,CL_MEM_DEVICE|CL_EVENT_NOWAIT);

   clarg_set_global(cp,k_addvec,0,aa);
   clarg_set_global(cp,k_addvec,1,bb);
   clarg_set_global(cp,k_addvec,2,cc);

   clfork(cp,0,k_addvec,&amp;ndr,CL_EVENT_NOWAIT);

   clmsync(cp,0,cc,CL_MEM_HOST|CL_EVENT_NOWAIT);

   clwait(cp,0,CL_MEM_EVENT|CL_KERNEL_EVENT);

   for(i=0;i&lt;SIZE;i++) printf("%f %f %f\n",aa[i],bb[i],cc[i]);

   if (aa) clfree(aa);
   if (bb) clfree(bb);
   if (cc) clfree(cc);

   clclose(cp,clh);
}
  </pre>
</div>

<p></p>

<p><span style="font-family: Times New Roman,Times,serif">The following example
shows the use of STDCL for a simple program that adds two vectors on two
GPU:</span></p>

<div style="background-color:#e8e8e8;">
<pre>/* example #2 */

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include "stdcl.h"

#define SIZE 1024

int main()
{
   int i,n;

   CLCONTEXT* cp = stdgpu;

   void* clh = clopen(cp, "add_vec.cl",CLLD_NOW);
   cl_kernel k_addvec = clsym(cp, clh, "addvec_kern", CLLD_NOW);

   float* aa[2];
   float* bb[2];
   float* cc[2];

   aa[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   aa[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   bb[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   bb[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   cc[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   cc[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);

   for(i=0;i&lt;SIZE/2;i++) {
      aa[0][i] = 111.0f * i;
      aa[1][i] = 111.0f * (SIZE/2 + i);
      bb[0][i] = 222.0f * i;
      bb[1][i] = 222.0f * (SIZE/2 + i);
   }

   bzero(cc[0],SIZE*sizeof(float));
   bzero(cc[1],SIZE*sizeof(float));

   clndrange_t ndr = clndrange_init1d(0,SIZE/2,64);

   clmsync(cp,0,aa[0],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,1,aa[1],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,0,bb[0],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,1,bb[1],CL_MEM_DEVICE|CL_EVENT_NOWAIT);

   clarg_set_global(cp,k_addvec,0,aa[0]);
   clarg_set_global(cp,k_addvec,1,bb[0]);
   clarg_set_global(cp,k_addvec,2,cc[0]);

   clfork(cp,0,k_addvec,&amp;ndr,CL_EVENT_NOWAIT);

   clmsync(cp,0,cc[0],CL_MEM_HOST|CL_EVENT_NOWAIT);

   clflush(cp,0,0);

   clarg_set_global(cp,k_addvec,0,aa[1]);
   clarg_set_global(cp,k_addvec,1,bb[1]);
   clarg_set_global(cp,k_addvec,2,cc[1]);

   clfork(cp,1,k_addvec,&amp;ndr,CL_EVENT_NOWAIT);

   clmsync(cp,1,cc[1],CL_MEM_HOST|CL_EVENT_NOWAIT);

   clflush(cp,1,0);

   clwait(cp,0,CL_MEM_EVENT|CL_KERNEL_EVENT);
   clwait(cp,1,CL_MEM_EVENT|CL_KERNEL_EVENT);

   for(i=0;i&lt;SIZE/2;i++) printf("%f %f %f\n",aa[0][i],bb[0][i],cc[0][i]);
   for(i=0;i&lt;SIZE/2;i++) printf("%f %f %f\n",aa[1][i],bb[1][i],cc[1][i]);

   if (aa[0]) clfree(aa[0]);
   if (aa[1]) clfree(aa[1]);
   if (bb[0]) clfree(bb[0]);
   if (bb[1]) clfree(bb[1]);
   if (cc[0]) clfree(cc[0]);
   if (cc[1]) clfree(cc[1]);

   clclose(cp,clh);
}
  </pre>
</div>

<p></p>
<hr />

<h2><a name="Manual" id="Manual">Manual Pages</a></h2>

<table border="1">
  <col />
  <col />
  <tbody>
    <tr>
      <td>overview</td>
      <td><a href="#STDLC">stdcl(3)</a></td>
    </tr>
    <tr>
      <td>dynamic loader</td>
      <td><a href="#CLOPEN">clopen(3)</a>, <a href="#CLOPEN">clsym(3)</a>, <a
        href="#CLOPEN">clclose(3)</a></td>
    </tr>
    <tr>
      <td>memory management</td>
      <td><a href="#CLMALLOC">clmalloc(3)</a>, <a
        href="#CLMALLOC">clfree(3)</a>, <a href="#CLMALLOC">clsizeofmem(3)</a>,
        <a href="#CLMSYNC">clmsync(3)</a>, <a
        href="#CLMATTACH">clmattach(3)</a>, <a
        href="#CLMATTACH">clmdetach(3)</a></td>
    </tr>
    <tr>
      <td>kernel management</td>
      <td><a href="#CLNDRANGE_INIT">clndrange_init1d(3)</a>, <a
        href="#CLNDRANGE_INIT">clndrange_init2d(3)</a>, <a
        href="#CLNDRANGE_INIT">clndrange_init3d(3)</a>, 

        <p><a href="#CLARG_SET">clarg_set(3)</a>, <a
        href="#CLARG_SET">clarg_set_global(3)</a>, <a
        href="#CLARG_SET">clarg_set_local(3)</a>, <a href="#CLFORK"></a></p>

        <p><a href="#CLFORK">clfork(3)</a></p>
      </td>
    </tr>
    <tr>
      <td>asynchronous operations</td>
      <td><a href="#CLFLUSH">clflush(3)</a>, <a
      href="#CLWAIT">clwait(3)</a></td>
    </tr>
  </tbody>
</table>

<p></p>
<hr />

<div>
<pre><a name="STDLC" id="STDLC">STDLC</a>(3)              Standard Compute Layer (CL) Manual              STDLC(3)



NAME
       stdcl - standard compute layer (CL) library functions

SYNOPSIS
       #include &lt;stdcl.h&gt;

       CLCONTEXT* stddev;
       CLCONTEXT* stdcpu;
       CLCONTEXT* stdgpu;
       CLCONTEXT* stdrpu;

       Link with -lstdcl.

DESCRIPTION
       The  standard  compute layer (CL) library (libstdcl) provides a simpli-
       fied interface to OpenCL designed to support the most typical use-cases
       in  a  style  inspired by familiar and traditional UNIX APIs for C pro-
       gramming.

       libstdcl provides managed OpenCL contexts  identified  with  a  context
       pointer  that is generally provided as an argument to library functions
       that transparently manage OpenCL constructs such as contexts,  devices,
       memory, kernels and events in a manner that simplifies their use.

       Default Contexts

       libstdcl  provides  several default contexts similar to the default I/O
       streams provided by stdio.  the following  default  contexts  are  pro-
       vided:

       stddev All devices for a given platform supported by the OpenCL API.

       stdcpu All  multi-core CPU processors for a given platform supported by
              the OpenCL API.

       stdgpu All many-core GPU processors for a given platform  supported  by
              the OpenCL API.

       stdrpu All  reconfigurable processors for a given platform supported by
              the OpenCL API.

       Dynamic CL Program Loader

       libstdcl provides a convenient interface  for  dynamically  loading  CL
       programs  and  accessing  CL  kernels.   Using the tool clld CL program
       source and binary files can be embedded  within  special  ELF  sections
       linked  against  other  object files on the host platform to generate a
       single executable.  The set of functions clopen(),  clsym(),  clclose()
       provide  a  convenient interface capable of dynamically loading CL pro-
       grams embedded within the executable as well as from an external  file.
       CL prorgams.

       Memory Management

       libstdcl provides functions for allocating and managing memory that may
       be shared between the host and CL co-processor devices.  Memory may  be
       allocated  with  clmalloc() and used transparently as the global memory
       for kernel execution on a CL device.   The  programmer  uses  a  single
       pointer  representing  the allocated memory which may be re-attached to
       various CL contexts using clmattach() and clmdetach().  Memory  consis-
       tency can be maintained using the clmsync() function which synchronizes
       memory between host and CL co-processor device.

       Kernel Execution

       libstdcl provides simplified interfaces for setting up the  index-space
       and arguments for kernel execution.  Executing a kernel on a particular
       CL co-processor device is supported using clfork() which allows  block-
       ing and non-blocking execution behavior.

       Management of Asynchronous Operations

       libstdcl  provides  event  management per device within each context to
       simplify the management of asynchronous multi-device  operations.   The
       function clwait() can be used to block on selected events within one of
       several per device event lists managed transparently.

EXAMPLE
       The following example shows a very simple program for  calculating  the
       outer product of two vectors using a GPU:

           #include &lt;stdcl.h&gt;

           int main() {

                int n = 1024;

                cl_float* aa = (cl_float*)clmalloc(stdgpu,n,0);
                cl_float* bb = (cl_float*)clmalloc(stdgpu,n,0);
                cl_float* cc = (cl_float*)clmalloc(stdgpu,n,0);

                /* initialize aa and bb */

                void* h = clopen(stdgpu,"outer_prod_kern.cl",0);
                cl_kernel krn = clsym(stdgpu,h,"outer_prod_kern");

                clndrange_t ndr = clndrange_init1d(0,n,4);

                clarg_set(stdgpu,krn,0,n);
                clarg_set_global(stdgpu,krn,1,aa);
                clarg_set_global(stdgpu,krn,2,bb);
                clarg_set_global(stdgpu,krn,3,cc);

                clfork(stdgpu,0,krn,ndr,CL_EVENT_NOWAIT);

                clmsync(stdgpu,0,cc,CL_EVENT_NOWAIT);

                clwait(stdgpu,0,CL_ALL_EVENTS|CL_EVENT_RELEASE);

                clclose(h);

                clfree(aa);
                clfree(bb);
                clfree(cc);

           }

ENVIRONMENT
       Executables  that  use the libstdcl library are affected by environment
       variables that control the behavior of the API.  The environment  vari-
       ables STDDEV, STDCPU, STDGPU, STDRPU may be set to 0 or 1 to disable or
       enable the context, respectively.  Additional environment variables are
       used to control the behavior of the context.

       The  environment  variables STDDEV_PLATFORM_NAME, STDCPU_PLATFORM_NAME,
       STDGPU_PLATFORM_NAME, STDRPU_PLATFORM_NAME can be used to set the  name
       of the preffered OpenCL platform to use for the context.

       As  an example, the following would force the stdgpu context to use the
       AMD APP platform:

              setenv STDGPU_PLATFORM_NAME AMD


       The    environment    varialble    STDDEV_MAX_NDEV,    STDCPU_MAX_NDEV,
       STDGPU_MAX_NDEV,  STDRPU_MAX_NDEV can be used to set the maximum number
       of devices provided by the respective context regardless of the  number
       of devices available.

       The   environment   variables  STDDEV_LOCK,  STDCPU_LOCK,  STDGPU_LOCK,
       STDRPU_LOCK can be used to setup exclusive locking  of  devices  across
       processes  with  matching lock values.  In combination with setting the
       maximum number of devices in the context,  the  lock  can  be  used  to
       achieve efficient device management between related processes.

       As  an  example, the following would allow the individual MPI processes
       on a given node to have exclusive access to a single GPU provided  that
       the  number  of  MPI  processes  per  node did not exceed the number of
       available GPUs:

          setenv STDGPU_MAX_NDEV 1; setenv STDGPU_LOCK $(MPI_JOB_ID)


AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU  Lesser  General Public License version 3.  There is NO WARRANTY to
       the extent permitted by law.

SEE ALSO
       clld(1),  clopen(3),  clsym(3),  clclose(3),  clmalloc(3),   clmsync(),
       clfork(3), clwait(3)



     "libstdcl-1.2"                2011-6-13                          STDLC(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLOPEN" id="CLOPEN">CLOPEN</a>(3)             Standard Compute Layer (CL) Manual             CLOPEN(3)



NAME
       clopen,  clsym,  clclose,  clerror,  claddr  - programming interface to
       dynamic CL loader

SYNOPSIS
       #include &lt;stdcl.h&gt;

       void* clopen( CLCONTEXT* cp, const char* filename, int flags);

       void* clbuild( CLCONTEXT* cp, void* handle, char* uopts, int flags);

       cl_kernel clsym( CLCONTEXT* cp, void* handle, const char*  symbol,  int
       flags);

       int claddr( CLCONTEXT* cp, void* addr, CL_info* info);

       char* clerror( void );

       int clclose( CLCONTEXT* cp, void* handle);

       Link with -lstdcl.

DESCRIPTION
       The  functions clopen(), clsym(), clclose(), and clerror() implement an
       interface for dynamically loading compute layer (CL) kernels.

       The function clopen() loads the CL source or binary program file  named
       by  the  NULL-terminated  string  filename and returns an opaque handle
       that may be used as a reference in subsequent calls.  If filename is  a
       NULL pointer then a handle for the main program executable is returned.
       If the flag CLLD_NOBUILD is used then the CL source will  not  be  com-
       piled.   This  may  be  used  to defer the compilation and build to the
       clbuild() call which can accept compiler options.

       The function clbuild() is used for defered compilation and allows  com-
       piler  options to be passed.  The combination of clopen() with the flag
       CLLD_NOBUILD and clbuild() is equivalent to a standard clopen() call.

       The funcion clsym() takes a handle to a CL source or binary program and
       a  NULL-terminated symbol name and returns the associated CL kernel.  A
       CL context pointer must be specififed to identify  the  appropriate  CL
       kernel  to  return.  If handle is NULL then all CL programs loaded into
       the specified CL context are searched.

       The function clclose() decrements the reference count on the associated
       handle.   If  the  reference count drops to zero then the CL program is
       unloaded.  The function clclose() returns the reference count  on  suc-
       cess and -1 on error.

       The  function  clerror() returns a human readable string describing the
       most recent error that has occured as a result of a call to any of  the
       functions  clopen(),  clsym(),  clclose()  since the last call to cler-
       ror().  If no error has occured NULL is returned.

       The function claddr() takes as an argument a CL  kernel  and  tries  to
       resolve the name and file where it is located.  Information is returned
       in the cl_kernel_info structure:

           struct cl_kernel_info {
                const char* cli_fname;
                CLCONTEXT* cli_cp;
                unsigned int cli_devnum;
                const char* cli_kname;
           };

       If no matching kernel is found the fields are set  to  NULL.   claddr()
       returns zero on error and non-zero on success.

EXAMPLE
AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clld(1), clload(3), stdcl(3)



libstdcl-1.2                       2011-6-13                         CLOPEN(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLMALLOC" id="CLMALLOC">CLMALLOC</a>(3)           Standard Compute Layer (CL) Manual           CLMALLOC(3)



NAME
       clmalloc,  clfree,  clsizeofmem - Allocate and free dynamic memory with
       CL bindings for use with co-processor devices

SYNOPSIS
       #include &lt;stdcl.h&gt;

       void* clmalloc( CLCONTEXT* cp, size_t size, int flags);

       void* clmrealloc( CLCONTEXT* cp, void* ptr, size_t size, int flags);

       void clfree( void* ptr);

       void clmctl( void* ptr);

       int clmctl( void* ptr, int op, ... );

       int clmctl_va( void* ptr, int op, va_list ap);

       size_t clsizeofmem(void* ptr);

       Link with -lstdcl.

DESCRIPTION
       clmalloc() allocates memory suitable for sharing between compute  layer
       (CL)  co-processor  devices  within a CL context.  clmalloc() allocates
       size bytes and returns a pointer to the allocated memory.   The  memory
       is not cleared.  If size is 0, then clmalloc() returns a unique pointer
       value that can later be safely passed to clfree().  If called with  the
       flag  CL_MEM_DETACHED  the  allocation will no be attached to a CL con-
       text.

       clmrealloc() re-allocates memory suitable for sharing  between  compute
       layer  (CL)  co-processor  devices within a CL context.  If ptr is 0 or
       NULL clmalloc() is called.  If size is 0,  then  clmalloc()  returns  a
       unique pointer value that can later be safely passed to clfree().

       clfree() frees the memory space pointed to by ptr, which must have been
       returned  by  a  previous  call  to  clmalloc().   Otherwise,   or   if
       clfree(ptr)  has already been called before, the behavior is undefined.
       It is considered an error to call clfree(ptr) if ptr is 0 or NULL.

       clmctl() and clmctl_va() are used to control the state of the allocated
       memory.   The  only  distinction  is that clmctl_va() accepts a va_list
       directly.

       clsizeofmem() returns the size of the allocated memory associated  with
       ptr.   If  ptr  does not reference memory allocated by a call to clmal-
       loc(), and for which clfree() has not  been  called,  the  behavior  is
       undefined.

RETURN VALUE
       If  successful  clmalloc(3)  returns  a pointer to the allocated memory
       that is suitably aligned and suitable for sharing with CL  co-processor
       devices.  On error, returns NULL.

       clfree() returns no value.

       clsizeofmem()  returns  the  size  in bytes of the memory pointed to by
       ptr.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clmattach(3), clmdetach(3), clmsync(3), stdcl(3), malloc(3)



libstdcl-1.2                       2011-6-13                       CLMALLOC(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLMATTACH" id="CLMATTACH">CLMATTACH</a>(3)          Standard Compute Layer (CL) Manual          CLMATTACH(3)



NAME
       clmattach, clmdetach - Attach and detach memory from a CL context

SYNOPSIS
       #include &lt;stdcl.h&gt;

       int clmattach( CLCONTEXT* cp, void* ptr );

       int clmdetach( void* ptr );

       Link with -lstdcl.

DESCRIPTION
       clmattach()  is  used to attach memory to a compute layer (CL) context.
       The memory pointed to by ptr must  be  allocated  with  clmalloc()  and
       suitable  for sharing between the host and CL co-processor devices.  In
       order to change the  attachment  of  memory  from  one  CL  context  to
       another,  the  memory  must  first be unattached using a call to clmde-
       tach().  It is an error to pass  clmattach()  memory  that  is  already
       attached to a CL context.

       clmdetach()  is  used  to  detach memory from a CL context.  The memory
       pointed to by ptr must be allocated with clmalloc()  and  suitable  for
       sharing between the host and CL co-processor devices.

       If ptr does not point to memory allocated by clmalloc() the behavior of
       clmattach() and clmdetach() is undefined.

RETURN VALUE
       Both clmattach() and clmdetach() return 0 on success.  On error, -1  is
       returned and errno is set appropriately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clmalloc(3), clfree(3), clmsync(3), malloc(3), stdcl(3)



libstdcl-1.2                       2011-6-13                      CLMATTACH(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLMSYNC" id="CLMSYNC">CLMSYNC</a>(3)            Standard Compute Layer (CL) Manual            CLMSYNC(3)



NAME
       clmsync - Synchronize memory between host and co-processor device

SYNOPSIS
       #include &lt;stdcl.h&gt;

       cl_event  clmsync(  CONTEXT*  cp,  unsigned  int devnum, void* ptr, int
       flags);

       Link with -lstdcl.

DESCRIPTION
       clmsync() is used to synchronize memory between the host and a  compute
       layer (CL) co-processor device.  The memory pointed to by ptr must have
       been created using a call to clmalloc() and associated with a  CL  con-
       text.

       The  behavior  of  clmsync()  is controlled by the flags argument which
       must be set with either CL_MEM_HOST or CL_MEM_DEVICE.  These flags  are
       mutually exclusive and it is an error to set both or none.  The follow-
       ing flags may be used:

       CL_MEM_HOST
              clmsync() will sync the memory on the host.

       CL_MEM_DEVICE
              clmsync() will sync the memory on the device.

       CL_EVENT_WAIT
              clmsync() will block until the operation has completed.

       CL_EVENT_NOWAIT
              clmsync() will return immediately.  The programmer  must  ensure
              that the operation has completed using clwait() or clwaitev().

       CL_EVENT_NORELEASE
              Used  with  CL_EVENT_WAIT to prevent clfork() from releasing the
              CL event generated by the operation.  If this flag is  used  the
              programmer is responsible for releasing the returned event using
              clReleaseEvent().  This flag has no effect when  CL_EVENT_NOWAIT
              is used.  CL_EVENT_RELEASE This flag is deprecated and should no
              longer be used.

RETURN VALUE
       On error clmsync() will return (cl_event)(-1) and errno is  set  appro-
       priately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clwait(3), clwaitev(3), clmalloc(3), clfree(3), stdcl(3)



libstdcl-1.2                       2011-6-13                        CLMSYNC(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLNDRANGE_1" id="CLNDRANGE_1">CLNDRANGE_INIT</a>(3)     Standard Compute Layer (CL) Manual     CLNDRANGE_INIT(3)



NAME
       clndrange_init1d,  clndrange_init2d,  clndrange_init3d - Initialize the
       index-space (NDRange) for the execution of a CL kernel

SYNOPSIS
       #include &lt;stdcl.h&gt;

       clndrange_t clndrange_init1d( gtoff0,gt0,lt0);

       clndrange_t clndrange_init2d( gtoff0,gt0,lt0, gtoff1,gt1,lt1);

       clndrange_t    clndrange_init3d(    gtoff0,gt0,lt0,     gtoff1,gt1,lt1,
       gtoff2,gt2,lt2);

DESCRIPTION
       clndrange_init()  family  of macros are used to initialize an object of
       type clndrange_t that defines the index-space for the execution of a CL
       kernel.  The values of gtoffn, gtn, ltn define the global index offset,
       global index range and local index range, respectively,  for  dimension
       n.   The  index-space defines the work-group and work-item partitioning
       for the kernel execution.

EXAMPLES
       The initialization of a 1-D index-space of  16  work-items  with  work-
       group size of 2 and no global offset:

               clndrange_t ndr = clndrange_init1d( 0,16,2 );

       The  initialization  of  a 2-D index-space of 64 by 128 work-items with
       work-group size of 2 by 4 with a global work-item offset of 32,64:

               clndrange_t ndr = clndrange_init1d( 32,64,2, 64,128,4 );

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clndrange_set(3), clfork(3), stdcl(3)



libstdcl-1.2                       2011-6-13                 CLNDRANGE_INIT(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLNDRANGE_" id="CLNDRANGE_">CLNDRANGE_SET</a>(3)      Standard Compute Layer (CL) Manual      CLNDRANGE_SET(3)



NAME
       clndrange_set1d, clndrange_set2d, clndrange_set3d - Set the index-space
       (NDRange) for the execution of a CL kernel

SYNOPSIS
       #include &lt;stdcl.h&gt;

       clndrange_set1d( clndrange_t ndr, gtoff0,gt0,lt0);

       clndrange_set2d( clndrange_t ndr, gtoff0,gt0,lt0, gtoff1,gt1,lt1);

       clndrange_set3d(  clndrange_t  ndr,   gtoff0,gt0,lt0,   gtoff1,gt1,lt1,
       gtoff2,gt2,lt2);

DESCRIPTION
       clndrange_set()  family  of  macros  are  used to set an object of type
       clndrange_t to define the index-space for the execution of a CL kernel.
       The  values  of gtoffn, gtn, ltn define the global index offset, global
       index range and local index range, respectively, for dimension n.   The
       index-space  defines  the work-group and work-item partitioning for the
       kernel execution.

EXAMPLES
       Setting a 1-D index-space of 16 work-items with work-group  size  of  2
       and no global offset:

               clndrange_t ndr;
               ...
               clndrange_set1d( ndr, 0,16,2 );

       Setting  a 2-D index-space of 64 by 128 work-items with work-group size
       of 2 by 4 with a global work-item offset of 32,64:

               clndrange_t ndr;
               ...
               clndrange_set2d( ndr, 32,64,2, 64,128,4 );

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clndrange_init(3), clfork(3), stdcl(3)



libstdcl-1.2                       2011-6-13                  CLNDRANGE_SET(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLARG_SET" id="CLARG_SET">CLARG_SET</a>(3)          Standard Compute Layer (CL) Manual          CLARG_SET(3)



NAME
       clarg_set, clarg_set_global, clarg_set_local - Set CL kernel arguments

SYNOPSIS
       #include &lt;stdcl.h&gt;

       void  clarg_set(  CLCONTEXT* cp, cl_kernel krn, unsigned int argnum, Tn
       arg);

       void clarg_set_global(  CLCONTEXT*  cp,  cl_kernel  krn,  unsigned  int
       argnum, void* ptr);

       void  clarg_set_local(  CLCONTEXT*  cp,  cl_kernel  krn,  unsigned  int
       argnum, size_t sizeb);

DESCRIPTION
       clarg_set(), clarg_set_global() and clarg_set_local() are used  to  set
       the argnum argument of the CL kernel krn prior to kernel execution.

       clarg_set()  is  used  for  setting arguments of intrinsic type such as
       cl_int, cl_float or cl_float4, etc.  For  clarg_set()  Tn  can  be  any
       valid scalar or vector type.

       clarg_set_global  is  used  for setting arguments of pointers to global
       memory where ptr points to memory that was allocated using  a  call  to
       clmalloc() and attached to the CL context of the target kernel.

       clarg_set_local()  is  used  for setting arguments of pointers to local
       memory where sizeb indicates the size in bytes of the local memory that
       is to be allocated.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clfork(3), clsym(3), clmalloc(3), stdcl(3)



libstdcl-1.2                       2011-6-13                      CLARG_SET(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLFORK" id="CLFORK">CLFORK</a>(3)             Standard Compute Layer (CL) Manual             CLFORK(3)



NAME
       clfork - Execute a CL kernel

SYNOPSIS
       #include &lt;stdcl.h&gt;

       cl_event  clfork(  CLCONTEXT*  cp,  unsigned int devnum, cl_kernel krn,
       clndrange_t* ndr, int flags);

       Link with -lstdcl.

DESCRIPTION
       clfork() is used to execute a CL kernel on a  specified  compute  layer
       (CL)  co-processor  device.   The  arguments for the kernel must be set
       prior to the call to clfork() using the  clarg_set*()  functions.   The
       kernel is executed over an index-space of work-items defined by ndr.

       The behavior of clfork() can be controlled using the following flags:

       CL_EVENT_WAIT
              clfork() will block until the operation has completed.

       CL_EVENT_NOWAIT
              clfork()  will  return  immediately.  The programmer must ensure
              that the operation has completed using clwait() or clwaitev().

       CL_EVENT_NORELEASE
              Used with CL_EVENT_WAIT to prevent clfork() from  releasing  the
              CL  event  generated by the operation.  If this flag is used the
              programmer is responsible for releasing the returned event using
              clReleaseEvent().   This flag has no effect when CL_EVENT_NOWAIT
              is used.  CL_EVENT_RELEASE This flag is deprecated and should no
              longer be used.

RETURN VALUE
       On error clfork() will return (cl_event)(-1) and errno is set appropri-
       ately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clarg_set(3),    clndrange_init(3),    clndrange_set(3),     clwait(3),
       clwaitev(3), stdcl(3)



libstdcl-1.2                       2011-6-13                         CLFORK(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLFLUSH" id="CLFLUSH">CLFLUSH</a>(3)            Standard Compute Layer (CL) Manual            CLFLUSH(3)



NAME
       clflush - Flush the CL command queue

SYNOPSIS
       #include &lt;stdcl.h&gt;

       int clflush( CLCONTEXT* cp, cl_uint devnum, int flags);

       Link with -lstdcl.

DESCRIPTION
       clflush()  is  used to flush the OpenCL command queue for device number
       devnum within a CL context.  For certain OpenCL implementations this is
       necessary to initiate operations to be executed asychronously.

       The flags argument is reserved for future use and presently ignored.

RETURN VALUE
       On  error  clflush() will return (cl_event)(-1) and errno is set appro-
       priately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2010-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clfork(3), clmsync(3), clwait(3), stdcl(3)



libstdcl-1.2                       2011-6-13                        CLFLUSH(3)</pre>
</div>
<hr />

<div>
<pre><a name="CLWAIT" id="CLWAIT">CLWAIT</a>(3)             Standard Compute Layer (CL) Manual             CLWAIT(3)



NAME
       clwait - Block on one or more CL events

SYNOPSIS
       #include &lt;stdcl.h&gt;

       cl_event clwait( CLCONTEXT* cp, cl_uint devnum, int flags);

       Link with -lstdcl.

DESCRIPTION
       clwait()  is used to block on the completion of one or more outstanding
       events for device number devnum within  a  CL  context.   The  type  of
       events are specificed by selecting one or more event lists as described
       below.

       One or more event lists may be selected using a combination of the fol-
       lowing flags:

       CL_KERNEL_EVENT
              Block on events in the ordered kernel event list.

       CL_MEM_EVENT
              Block on events in the ordered memory event list.

       Note that if both kernel and memory event lists are specified, the ker-
       nel event list has first priority.  Specifically, clwait()  will  first
       block  on  all  outstanding kernel events and subsequently block on all
       outstanding memory events.

       The bahavior of clwait() can be controlled using the following flags:

       CL_EVENT_NORELEASE
              Used with CL_EVENT_WAIT to prevent clfork() from  releasing  the
              CL  event  generated by the operation.  If this flag is used the
              programmer is responsible for releasing the returned event using
              clReleaseEvent().   This flag has no effect when CL_EVENT_NOWAIT
              is used.  CL_EVENT_RELEASE This flag is deprecated and should no
              longer be used.

RETURN VALUE
       On error clwait() will return (cl_event)(-1) and errno is set appropri-
       ately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009-2011 Brown Deer Technology, LLC.  Licensed under the
       GNU Lesser General Public License version 3 (LGPLv3).  There is NO WAR-
       RANTY to the extent permitted by law.

SEE ALSO
       clfork(3), clmsync(3), clwaitev(3), stdcl(3)



libstdcl-1.2                       2011-6-13                         CLWAIT(3)</pre>
</div>
<hr />

<p></p>
</body>
</html>
